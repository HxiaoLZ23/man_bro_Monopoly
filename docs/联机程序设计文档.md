# 大富翁游戏联机程序设计文档

## 1. 职责概述

联机程序员负责实现游戏的网络功能，包括：
- 多人联机系统（支持3-6名玩家）
- 数据同步机制
- 断线重连功能
- 网络状态管理

## 2. 核心功能实现

### 2.1 网络架构
```python
import socket
import threading
import json
import time
import queue

class NetworkManager:
    def __init__(self):
        self.server = None
        self.clients = {}
        self.game_state = None
        self.message_queue = queue.Queue()
        self.running = False
        self.max_players = 6
        self.min_players = 3
    
    def start_server(self, host='0.0.0.0', port=5000):
        """启动服务器"""
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((host, port))
        self.server.listen(self.max_players)
        self.running = True
        
        # 启动监听线程
        threading.Thread(target=self.accept_connections).start()
        # 启动消息处理线程
        threading.Thread(target=self.process_messages).start()
    
    def accept_connections(self):
        """接受客户端连接"""
        while self.running:
            try:
                if len(self.clients) >= self.max_players:
                    time.sleep(1)
                    continue
                    
                client_socket, address = self.server.accept()
                client_id = self.generate_client_id()
                self.clients[client_id] = {
                    'socket': client_socket,
                    'address': address,
                    'last_heartbeat': time.time(),
                    'player_info': None
                }
                # 发送客户端ID
                self.send_to_client(client_id, {
                    'type': 'init',
                    'client_id': client_id
                })
                # 启动心跳检测线程
                threading.Thread(target=self.heartbeat_check, args=(client_id,)).start()
            except Exception as e:
                print(f"接受连接错误: {e}")
    
    def connect_client(self, host='localhost', port=5000):
        """连接服务器"""
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            client_socket.connect((host, port))
            # 启动接收消息线程
            threading.Thread(target=self.receive_messages, args=(client_socket,)).start()
            # 启动心跳发送线程
            threading.Thread(target=self.send_heartbeat, args=(client_socket,)).start()
            return client_socket
        except Exception as e:
            print(f"连接服务器错误: {e}")
            return None
    
    def generate_client_id(self):
        """生成客户端ID"""
        return f"client_{len(self.clients) + 1}"
    
    def send_to_client(self, client_id, message):
        """发送消息给指定客户端"""
        if client_id in self.clients:
            try:
                client_socket = self.clients[client_id]['socket']
                data = json.dumps(message).encode('utf-8')
                client_socket.send(data)
            except Exception as e:
                print(f"发送消息错误: {e}")
    
    def broadcast(self, message):
        """广播消息给所有客户端"""
        for client_id in self.clients:
            self.send_to_client(client_id, message)
    
    def process_messages(self):
        """处理消息队列"""
        while self.running:
            try:
                message = self.message_queue.get()
                self.handle_message(message)
            except Exception as e:
                print(f"处理消息错误: {e}")
    
    def handle_message(self, message):
        """处理消息"""
        message_type = message.get('type')
        if message_type == 'game_state':
            self.handle_game_state(message)
        elif message_type == 'player_action':
            self.handle_player_action(message)
        elif message_type == 'heartbeat':
            self.handle_heartbeat(message)
    
    def heartbeat_check(self, client_id):
        """心跳检测"""
        while self.running:
            if client_id in self.clients:
                last_heartbeat = self.clients[client_id]['last_heartbeat']
                if time.time() - last_heartbeat > 10:  # 10秒超时
                    self.handle_client_disconnect(client_id)
                    break
            time.sleep(1)
    
    def send_heartbeat(self, client_socket):
        """发送心跳包"""
        while self.running:
            try:
                message = {
                    'type': 'heartbeat',
                    'timestamp': time.time()
                }
                data = json.dumps(message).encode('utf-8')
                client_socket.send(data)
                time.sleep(5)  # 每5秒发送一次
            except Exception as e:
                print(f"发送心跳包错误: {e}")
                break
```

### 2.2 数据同步
```python
class SyncManager:
    def __init__(self, network_manager):
        self.network_manager = network_manager
        self.game_state = None
        self.sync_interval = 0.1  # 同步间隔（秒）
        self.last_sync_time = 0
    
    def sync_game_state(self):
        """同步游戏状态"""
        current_time = time.time()
        if current_time - self.last_sync_time >= self.sync_interval:
            self.last_sync_time = current_time
            
            # 准备同步数据
            sync_data = {
                'type': 'game_state',
                'data': {
                    'players': self.get_players_data(),
                    'map': self.get_map_data(),
                    'items': self.get_items_data(),
                    'bank': self.get_bank_data(),
                    'current_player': self.get_current_player_data(),
                    'game_phase': self.get_game_phase_data()
                }
            }
            
            # 广播同步数据
            self.network_manager.broadcast(sync_data)
    
    def get_players_data(self):
        """获取玩家数据"""
        players_data = []
        for player in self.game_state.players:
            player_data = {
                'id': player.id,
                'name': player.name,
                'money': player.money,
                'bank_balance': player.bank_balance,
                'position': player.position,
                'items': [item.id for item in player.items],
                'properties': [prop.id for prop in player.properties],
                'in_jail': player.in_jail,
                'jail_turns': player.jail_turns
            }
            players_data.append(player_data)
        return players_data
    
    def get_map_data(self):
        """获取地图数据"""
        map_data = {
            'width': self.game_state.map.width,
            'height': self.game_state.map.height,
            'cells': []
        }
        
        for cell in self.game_state.map.cells:
            cell_data = {
                'position': cell.position,
                'type': cell.type,
                'owner': cell.owner.id if cell.owner else None,
                'level': cell.level,
                'has_roadblock': cell.has_roadblock
            }
            map_data['cells'].append(cell_data)
        
        return map_data
    
    def get_items_data(self):
        """获取道具数据"""
        items_data = []
        for item in self.game_state.items:
            item_data = {
                'id': item.id,
                'type': item.type,
                'position': item.position if hasattr(item, 'position') else None,
                'owner': item.owner.id if item.owner else None
            }
            items_data.append(item_data)
        return items_data
    
    def get_bank_data(self):
        """获取银行数据"""
        return {
            'balance': self.game_state.bank.balance,
            'interest_rate': self.game_state.bank.interest_rate,
            'last_interest_time': self.game_state.bank.last_interest_time
        }
    
    def get_current_player_data(self):
        """获取当前玩家数据"""
        current_player = self.game_state.get_current_player()
        return {
            'id': current_player.id if current_player else None,
            'turn_number': self.game_state.turn_number
        }
    
    def get_game_phase_data(self):
        """获取游戏阶段数据"""
        return {
            'phase': self.game_state.current_phase,
            'phase_start_time': self.game_state.phase_start_time
        }
```

### 2.3 断线重连
```python
class ReconnectionManager:
    def __init__(self, network_manager):
        self.network_manager = network_manager
        self.disconnected_clients = {}
        self.reconnect_timeout = 30  # 重连超时时间（秒）
    
    def handle_client_disconnect(self, client_id):
        """处理客户端断线"""
        if client_id in self.network_manager.clients:
            client_data = self.network_manager.clients[client_id]
            self.disconnected_clients[client_id] = {
                'data': client_data,
                'disconnect_time': time.time(),
                'game_state': self.get_client_game_state(client_id)
            }
            # 通知其他客户端
            self.network_manager.broadcast({
                'type': 'player_disconnect',
                'client_id': client_id
            })
    
    def handle_reconnect(self, client_id, client_socket):
        """处理客户端重连"""
        if client_id in self.disconnected_clients:
            # 检查是否超时
            disconnect_time = self.disconnected_clients[client_id]['disconnect_time']
            if time.time() - disconnect_time <= self.reconnect_timeout:
                # 恢复客户端连接
                self.network_manager.clients[client_id] = {
                    'socket': client_socket,
                    'address': self.disconnected_clients[client_id]['data']['address'],
                    'last_heartbeat': time.time(),
                    'player_info': self.disconnected_clients[client_id]['data']['player_info']
                }
                # 发送游戏状态
                self.send_game_state(client_id)
                # 通知其他客户端
                self.network_manager.broadcast({
                    'type': 'player_reconnect',
                    'client_id': client_id
                })
                # 移除断线记录
                del self.disconnected_clients[client_id]
                return True
        return False
    
    def get_client_game_state(self, client_id):
        """获取客户端游戏状态"""
        return {
            'player': self.get_player_state(client_id),
            'game': self.get_game_state()
        }
    
    def send_game_state(self, client_id):
        """发送游戏状态给重连的客户端"""
        game_state = {
            'type': 'game_state',
            'data': {
                'players': self.get_players_data(),
                'map': self.get_map_data(),
                'items': self.get_items_data(),
                'bank': self.get_bank_data(),
                'current_player': self.get_current_player_data(),
                'game_phase': self.get_game_phase_data()
            }
        }
        self.network_manager.send_to_client(client_id, game_state)
    
    def check_timeout_clients(self):
        """检查超时的断线客户端"""
        current_time = time.time()
        timeout_clients = []
        
        for client_id, data in self.disconnected_clients.items():
            if current_time - data['disconnect_time'] > self.reconnect_timeout:
                timeout_clients.append(client_id)
        
        for client_id in timeout_clients:
            # 通知其他客户端
            self.network_manager.broadcast({
                'type': 'player_timeout',
                'client_id': client_id
            })
            # 移除断线记录
            del self.disconnected_clients[client_id]
```

### 2.4 网络协议
```python
class NetworkProtocol:
    # 消息类型
    MESSAGE_TYPES = {
        'INIT': 'init',                    # 初始化连接
        'GAME_STATE': 'game_state',        # 游戏状态同步
        'PLAYER_ACTION': 'player_action',  # 玩家操作
        'HEARTBEAT': 'heartbeat',          # 心跳包
        'DISCONNECT': 'disconnect',        # 断开连接
        'RECONNECT': 'reconnect',          # 重新连接
        'ERROR': 'error'                   # 错误信息
    }
    
    # 玩家操作类型
    ACTION_TYPES = {
        'MOVE': 'move',                    # 移动
        'USE_ITEM': 'use_item',            # 使用道具
        'BUY_PROPERTY': 'buy_property',    # 购买房产
        'UPGRADE_PROPERTY': 'upgrade_property',  # 升级房产
        'BANK_OPERATION': 'bank_operation'  # 银行操作
    }
    
    @staticmethod
    def create_message(message_type, data=None):
        """创建消息"""
        message = {
            'type': message_type,
            'timestamp': time.time()
        }
        if data:
            message['data'] = data
        return message
    
    @staticmethod
    def parse_message(message_data):
        """解析消息"""
        try:
            message = json.loads(message_data)
            if 'type' not in message:
                return None
            return message
        except json.JSONDecodeError:
            return None
    
    @staticmethod
    def validate_message(message):
        """验证消息"""
        required_fields = ['type', 'timestamp']
        return all(field in message for field in required_fields)
```

## 3. 接口设计

### 3.1 与基本程序的接口
```python
class GameNetworkInterface:
    def send_game_event(self, event):
        """发送游戏事件"""
        pass
    
    def receive_game_event(self):
        """接收游戏事件"""
        pass
    
    def sync_game_state(self):
        """同步游戏状态"""
        pass
```

### 3.2 与地图程序的接口
```python
class MapNetworkInterface:
    def sync_map_state(self):
        """同步地图状态"""
        pass
    
    def sync_player_position(self, player_id, position):
        """同步玩家位置"""
        pass
```

## 4. 开发任务

### 4.1 第一阶段：网络基础
1. 实现服务器-客户端架构
2. 实现基础网络通信
3. 实现数据序列化

### 4.2 第二阶段：数据同步
1. 实现游戏状态同步
2. 实现玩家操作同步
3. 实现地图状态同步

### 4.3 第三阶段：网络优化
1. 实现断线重连
2. 实现网络延迟补偿
3. 实现网络状态监控

## 5. 协作流程

### 5.1 与基本程序的协作
- 同步游戏状态
- 处理玩家操作
- 实现断线重连

### 5.2 与地图程序的协作
- 同步地图状态
- 处理玩家移动
- 同步格子效果

### 5.3 与策划的协作
- 实现网络规则
- 优化网络体验
- 处理网络异常

## 6. 网络协议

### 6.1 通信协议
- 使用TCP协议保证可靠性
- 使用JSON格式传输数据
- 实现心跳机制

### 6.2 数据包格式
```json
{
    "type": "event_type",
    "data": {
        "player_id": "player_id",
        "action": "action_type",
        "params": {}
    },
    "timestamp": "timestamp"
}
```

## 7. 测试要求

### 7.1 单元测试
- 测试网络连接
- 测试数据同步
- 测试断线重连

### 7.2 压力测试
- 测试多客户端连接
- 测试网络延迟
- 测试断线恢复

## 8. 性能要求

### 8.1 网络性能
- 连接延迟 < 100ms
- 数据同步延迟 < 50ms
- 断线重连时间 < 5s

### 8.2 资源占用
- 网络带宽 < 1Mbps
- 服务器内存 < 1GB
- 客户端内存 < 100MB

## 9. 开发工具

### 9.1 必需工具
- Python 3.8+
- PyCharm/VSCode
- Git
- Wireshark（网络分析）

### 9.2 推荐工具
- pytest（测试框架）
- black（代码格式化）
- pylint（代码检查）

## 10. 安全措施

### 10.1 数据安全
- 数据加密传输
- 防止数据篡改
- 防止作弊行为

### 10.2 服务器安全
- 防止DDoS攻击
- 防止SQL注入
- 防止越权访问

## 11. 错误处理

### 11.1 网络错误
- 连接超时处理
- 数据包丢失处理
- 网络异常处理

### 11.2 游戏错误
- 数据不同步处理
- 状态不一致处理
- 异常操作处理

## 12. 文档维护

### 12.1 代码文档
- 保持代码注释更新
- 记录重要设计决策
- 维护API文档

### 12.2 开发文档
- 记录开发进度
- 记录遇到的问题和解决方案
- 更新技术文档