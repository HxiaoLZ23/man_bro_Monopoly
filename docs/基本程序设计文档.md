# 大富翁基本程序设计文档

## 1. 职责概述
基本程序负责实现游戏的核心功能，包括游戏循环、玩家管理、道具系统、骰子系统、银行系统和房产系统等基础功能模块。

## 2. 核心功能

### 2.1 游戏循环
1. **回合管理**
   - 准备阶段：更换骰子、使用道具
   - 行动阶段：投掷骰子、移动、执行效果
   - 结束阶段：使用道具

2. **游戏状态**
   - 游戏初始化
   - 回合切换
   - 游戏结束判定

```python
class GameLoop:
    def __init__(self):
        self.game_state = GameState()
        self.player_manager = PlayerManager()
        self.map_manager = MapManager()
        self.event_manager = EventManager()
    
    def run(self):
        while not self.game_state.is_game_over():
            # 获取当前玩家
            current_player = self.player_manager.get_current_player()
            
            # 准备阶段
            self.preparation_phase(current_player)
            
            # 行动阶段
            self.action_phase(current_player)
            
            # 结束阶段
            self.end_phase(current_player)
            
            # 更新游戏状态
            self.game_state.next_turn()
            
            # 检查游戏是否结束
            if self.check_game_over():
                break
    
    def preparation_phase(self, player):
        """准备阶段：更换骰子、使用道具"""
        # 允许玩家更换骰子
        self.handle_dice_change(player)
        
        # 允许玩家使用一张道具卡
        self.handle_item_use(player)
    
    def action_phase(self, player):
        """行动阶段：投骰子、移动、执行格子效果"""
        # 投骰子
        steps = self.roll_dice(player)
        
        # 移动玩家
        self.map_manager.move_player(player, steps)
        
        # 获取当前格子
        current_cell = self.map_manager.get_current_cell(player)
        
        # 执行格子效果
        self.handle_cell_effect(player, current_cell)
    
    def end_phase(self, player):
        """结束阶段：使用道具、更新状态"""
        # 允许玩家使用一张道具卡
        self.handle_item_use(player)
        
        # 更新玩家状态
        self.update_player_status(player)
```

### 2.2 玩家管理
1. **玩家属性**
   - 名称/头像
   - 资金管理（初始20万）
   - 道具管理（初始3张路障）
   - 房产管理

2. **玩家操作**
   - 移动控制
   - 道具使用
   - 房产购买/升级
   - 银行存取款

```python
class PlayerManager:
    def __init__(self):
        self.players = []
        self.current_player_index = 0
    
    def add_player(self, player):
        """添加玩家"""
        self.players.append(player)
    
    def get_current_player(self):
        """获取当前玩家"""
        return self.players[self.current_player_index]
    
    def next_player(self):
        """切换到下一个玩家"""
        self.current_player_index = (self.current_player_index + 1) % len(self.players)
    
    def get_player_by_id(self, player_id):
        """根据ID获取玩家"""
        for player in self.players:
            if player.id == player_id:
                return player
        return None

class Player:
    def __init__(self, player_id, name, is_ai=False):
        self.id = player_id
        self.name = name
        self.is_ai = is_ai
        self.money = 200000  # 初始资金
        self.position = 0    # 初始位置
        self.items = []      # 道具列表
        self.properties = [] # 房产列表
        self.dice = "d6"     # 初始骰子
        self.status = {}     # 状态效果
    
    def add_money(self, amount):
        """增加金钱"""
        self.money += amount
    
    def remove_money(self, amount):
        """减少金钱"""
        if self.money >= amount:
            self.money -= amount
            return True
        return False
    
    def add_item(self, item):
        """添加道具"""
        self.items.append(item)
    
    def use_item(self, item_index):
        """使用道具"""
        if 0 <= item_index < len(self.items):
            item = self.items.pop(item_index)
            return item.use(self)
        return False
```

### 2.3 道具系统
1. **道具类型**
   - 路障（10,000）：直线距离≤14放置，碰到停止
   - 再装逼让你飞起来!!（20,000）：无视地图限制，钱散落
   - 庇护术（20,000）：不受道具影响
   - 六百六十六（15,000）：骰子结果全为6
   - 违规爆建（25,000）：房产升降级（无法降级四级房产）

2. **道具管理**
   - 道具获取
   - 道具使用
   - 道具效果实现

```python
class Item:
    def __init__(self, item_id, name, price, description):
        self.id = item_id
        self.name = name
        self.price = price
        self.description = description
    
    def use(self, player):
        """使用道具的抽象方法"""
        raise NotImplementedError

class Roadblock(Item):
    def __init__(self):
        super().__init__("roadblock", "路障", 10000, "放置路障阻止玩家移动")
    
    def use(self, player):
        """使用路障"""
        # 实现路障效果
        return True

class FlyCard(Item):
    def __init__(self):
        super().__init__("fly", "再装逼让你飞起来!!", 20000, "获得起飞效果，无视地图限制")
    
    def use(self, player):
        """使用飞行卡"""
        # 实现飞行效果
        player.status["fly"] = 3  # 持续3回合
        return True

class ItemManager:
    def __init__(self):
        self.items = {}
        self.init_items()
    
    def init_items(self):
        """初始化所有道具"""
        self.items["roadblock"] = Roadblock()
        self.items["fly"] = FlyCard()
        # 添加其他道具...
    
    def get_item(self, item_id):
        """获取道具"""
        return self.items.get(item_id)
    
    def create_item(self, item_id):
        """创建道具实例"""
        item = self.items.get(item_id)
        if item:
            return copy.deepcopy(item)
        return None
```

### 2.4 骰子系统
1. **骰子类型**
   - d8骰：10,000+1张道具卡
   - d12骰：50,000+1张道具卡
   - 双d6骰：10,000+3张道具卡
   - 双d8骰：50,000+3张道具卡
   - 三d6骰：40,000+4张道具卡
   - d20神力!!：77,777+7张道具卡

2. **骰子效果**
   - 基础投掷
   - d20神力特殊效果：
     - 投掷两枚20面骰，取最大值
     - 结果为20时：收益翻倍，惩罚减免
     - 结果为1时：惩罚翻倍，收益减免

```python
class Dice:
    def __init__(self, dice_type):
        self.type = dice_type
        self.sides = self.get_sides()
    
    def get_sides(self):
        """获取骰子面数"""
        dice_types = {
            "d6": 6,
            "d8": 8,
            "d12": 12,
            "d20": 20
        }
        return dice_types.get(self.type, 6)
    
    def roll(self):
        """投掷骰子"""
        return random.randint(1, self.sides)

class DiceManager:
    def __init__(self):
        self.dice_types = ["d6", "d8", "d12", "d20"]
    
    def create_dice(self, dice_type):
        """创建骰子"""
        if dice_type in self.dice_types:
            return Dice(dice_type)
        return Dice("d6")  # 默认返回d6
    
    def roll_dice(self, player):
        """玩家投掷骰子"""
        dice = self.create_dice(player.dice)
        return dice.roll()
```

### 2.5 银行系统
1. **存取款功能**
   - 存款操作
   - 取款操作
   - 余额管理（初始10万）

2. **利息系统**
   - 利息计算（每3轮一次，每个玩家都进行一次回合后即为一轮）
   - 利率设置：
     - 资产<100,000：5%
     - 资产≥100,000：10%
     - 资产≥300,000：20%
     - 资产≥500,000：30%

```python
class Bank:
    def __init__(self):
        self.interest_rates = {
            100000: 0.05,  # 10万以下 5%
            300000: 0.10,  # 10-30万 10%
            500000: 0.20,  # 30-50万 20%
            999999: 0.30   # 50万以上 30%
        }
    
    def calculate_interest(self, amount):
        """计算利息"""
        for threshold, rate in self.interest_rates.items():
            if amount < threshold:
                return amount * rate
        return amount * 0.30
    
    def deposit(self, player, amount):
        """存款"""
        if player.money >= amount:
            player.money -= amount
            player.bank_deposit = player.bank_deposit + amount if hasattr(player, 'bank_deposit') else amount
            return True
        return False
    
    def withdraw(self, player, amount):
        """取款"""
        if hasattr(player, 'bank_deposit') and player.bank_deposit >= amount:
            player.bank_deposit -= amount
            player.money += amount
            return True
        return False
```

### 2.6 房产系统
1. **房产属性**
   - 基础价格
   - 租金设置
   - 等级管理（0-4级）
   - 所有权管理

2. **房产操作**
   - 购买功能
   - 升级功能
   - 降级功能
   - 租金收取

```python
class Property:
    def __init__(self, property_id, name, price, rent):
        self.id = property_id
        self.name = name
        self.price = price
        self.rent = rent
        self.level = 0
        self.owner = None
    
    def upgrade(self):
        """升级房产"""
        if self.level < 3:
            self.level += 1
            self.rent *= 2
            return True
        return False
    
    def downgrade(self):
        """降级房产"""
        if self.level > 0:
            self.level -= 1
            self.rent /= 2
            return True
        return False
    
    def calculate_rent(self):
        """计算租金"""
        return self.rent * (self.level + 1)

class PropertyManager:
    def __init__(self):
        self.properties = {}
    
    def add_property(self, property_id, name, price, rent):
        """添加房产"""
        self.properties[property_id] = Property(property_id, name, price, rent)
    
    def get_property(self, property_id):
        """获取房产"""
        return self.properties.get(property_id)
    
    def buy_property(self, player, property_id):
        """购买房产"""
        property = self.get_property(property_id)
        if property and not property.owner and player.money >= property.price:
            player.money -= property.price
            property.owner = player
            player.properties.append(property)
            return True
        return False
```

## 3. 接口设计

### 3.1 与地图程序的接口
```python
class MapInterface:
    def get_current_position(self, player_id):
        """获取玩家当前位置"""
        pass
    
    def move_player(self, player_id, steps):
        """移动玩家"""
        pass
    
    def get_cell_effect(self, position):
        """获取格子效果"""
        pass
```

### 3.2 与联机程序的接口
```python
class NetworkInterface:
    def sync_game_state(self):
        """同步游戏状态"""
        pass
    
    def handle_player_action(self, action):
        """处理玩家操作"""
        pass
    
    def broadcast_game_event(self, event):
        """广播游戏事件"""
        pass
```

## 4. 开发任务

### 4.1 第一阶段：基础框架
1. 实现游戏主循环
2. 实现玩家回合管理
3. 实现基础游戏状态管理

### 4.2 第二阶段：核心功能
1. 实现骰子系统
2. 实现道具系统基础功能
3. 实现银行系统
4. 实现房产系统

### 4.3 第三阶段：AI系统
1. 实现AI决策系统
2. 实现AI行为模式
3. 实现AI难度调整

## 5. 协作流程

### 5.1 与地图程序的协作
- 提供玩家移动接口
- 处理地图事件
- 同步地图状态

### 5.2 与联机程序的协作
- 同步游戏状态
- 处理玩家操作
- 实现断线重连

### 5.3 与策划的协作
- 实现游戏规则
- 调整游戏平衡性
- 优化游戏体验

## 6. 代码规范

### 6.1 命名规范
- 类名：使用大驼峰命名法
- 方法名：使用小驼峰命名法
- 变量名：使用下划线命名法

### 6.2 注释规范
- 类注释：说明类的功能和用途
- 方法注释：说明方法的功能、参数和返回值
- 关键代码注释：说明复杂逻辑

## 7. 测试要求

### 7.1 单元测试
- 测试游戏主循环
- 测试玩家回合管理
- 测试游戏状态管理

### 7.2 集成测试
- 测试与地图程序的交互
- 测试与联机程序的交互
- 测试AI系统

## 8. 性能要求

### 8.1 响应时间
- 玩家操作响应时间 < 100ms
- 游戏状态更新延迟 < 50ms

### 8.2 资源占用
- CPU使用率 < 30%
- 内存占用 < 500MB

## 9. 开发工具

### 9.1 必需工具
- Python 3.8+
- PyCharm/VSCode
- Git
- Pygame

### 9.2 推荐工具
- pytest（测试框架）
- black（代码格式化）
- pylint（代码检查）

## 10. 文档维护

### 10.1 代码文档
- 保持代码注释更新
- 记录重要设计决策
- 维护API文档

### 10.2 开发文档
- 记录开发进度
- 记录遇到的问题和解决方案
- 更新技术文档